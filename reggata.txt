reggatad --- is a daemon (service) process that's main purpose is to watch for changes in filesystem and update tags database correspondingly. Also it manages the tags database (SQLite?) and provides an API for all operations with tagged files. This API uses reggata_client.

Instead of SQLite we may use:
- RocksDB http://rocksdb.org/docs/getting-started.html C++ simple key value store
- EJDB http://ejdb.org/doc/ql/ql.html C++ JSON database, very good query language, not maintained


Repository should have a list of required fileds. Every file with tags should have these fields set. E.g. 'rating'

## API
### init_repo(path_to_root_dir)
### add_tags_to_file(file_path, tag1, tag2, ...)
### remove_tags_from_file(file_path, tag1, tag2, ...)
### add_fields_to_file(file_path, field1(key1,val1), field2(key2,val2), ...)
### remove_fields_from_file(file_path, field_key1, field_key2, ...)
### list_file_tags_fields(file_path)
### search(query_string)

## File watch actions
### file_created - do nothing
### file_removed - remove file tags and fields from DB
### file_moved (renamed) - update file path
### file_modified - do nothing
### dir_created - do nothing
### dir_removed - remove all files tags and fields from DB recursively. Remove filewathes from dir and subdirs
### dir_moved (renamed) - update files paths for all files recursively

## Query String Language
### Examples:
tag1 AND tag2 AND tag3
tag1 OR tag2 OR tag3
tag1 AND (tag2 OR tag3)
tag1 OR tag2 AND tag3
field1==val1 => same as: field1 AND field1==val1, where field1 is a tag name.
field1==val1 OR field1==val2 ===>equivalent===> field1 AND (field1==val1 OR field1==val2)

tag1 | tag1 != NULL | all files with tag1
NOT tag1 | tag1 == NULL | all files without tag1

Fields are just tags with values. Values should be typed. Types supported are: string, number, datetime
Operations with tags are: AND, OR and braces
Operations with fields are: ==, !=, >, >=, <, <=, ~= (like)

t1 t2 t3 => files which has all three tags: t1 and t2 and t3
t1 t2|t3 => files with tag t1 and any of t2 or t3
(t1 t2)|t3 => files with tags t1 and t2 or just one tag t3
t1 f1>5 => files with tag t1 and field f1>5
All these queries could be performed against the whole repository, or any of repository subdirs. Very often case is to
perform a query on a subdir. So the mechanism for executing query to a repo root is just a particular case of "exec query in subdir"
Very simple way of executing queries is just filter files by subdir (recursively), then iterate over them and 
apply query predicate to every file.
For simplicity we may permit only one level of () braces grouping. Otherwise it would be too difficult to implement.

For queries parsing we need ANTLR (maybe?..)





